# Copyright 2022-2024 the Kubeapps contributors.
# SPDX-License-Identifier: Apache-2.0

---
name: General

permissions:
  contents: read
  packages: write

on:
  workflow_call:
    inputs:
      run_linters:
        type: boolean
        required: false
        default: true
      trigger_release:
        type: boolean
        required: false
        default: false
  workflow_dispatch:
    inputs:
      run_linters:
        type: boolean
        required: false
        default: true
        description: "Run linters"
      trigger_release:
        type: boolean
        required: false
        default: false
        description: "Trigger release process"
  push:
    branches:
      - enable_basic_github_actions

env:
  CHARTMUSEUM_VERSION: "3.10.4"
  CHARTS_REPO_ORIGINAL: "bitnami/charts"
  CHARTS_REPO_FORKED: "kubeapps-bot/charts"
  CHART_OCI_REPO: "ghcr.io/sap/kubeapps"
  # DEBUG_MODE allows to activate some SSH debugging steps, and modify the verbosity level of some scripts (eg. e2e-tests.sh)
  DEBUG_MODE: "false"
  DOCKER_REGISTRY_VERSION: "3.0.0"
  FLUX_VERSION: "v2.2.3"
  GITHUB_VERSION: "2.83.1"
  GOLANG_VERSION: "1.25.4"
  GOLANGCI_LINT_VERSION: "2.6.2"
  HELM_VERSION_MIN: "v3.18.6"
  HELM_VERSION_STABLE: "v4.0.0"
  IMAGES_TO_PUSH: "apprepository-controller dashboard asset-syncer pinniped-proxy kubeapps-apis oci-catalog"
  # IMG_DEV_TAG is the tags used for the Kubeapps docker images. Ideally there should be an IMG_PROD_TAG
  # but its value is dynamic and GitHub actions doesn't support it in the `env` block, so it is generated
  # as an output of the `setup` job.
  IMG_DEV_TAG: "build-${{ github.sha }}"
  # Apart from using a dev tag we use a different image ID to avoid polluting the tag history of the production tag
  IMG_MODIFIER: "-ci"
  IMG_REGISTRY: "ghcr.io"
  IMG_PREFIX: "sap/kubeapps/"
  # We use IMG_PREFIX_FOR_FORKS for development purposes, it's used when the workflow is run from a fork of the kubeapps repo
  IMG_PREFIX_FOR_FORKS: "your-dockerhub-username/"
  # Currently, we only build the images for linux/amd64 because building cross-platform images is extremely slow...
  IMG_PLATFORMS: "linux/amd64"
  K8S_KIND_VERSION: "v1.33.4@sha256:25a6018e48dfcaee478f4a59af81157a437f15e6e140bf103f85a2e7cd0cbbf2"
  KIND_VERSION: "v0.30.0"
  KUBEAPPS_REPO: "SAP/kubeapps"
  KUBECTL_VERSION: "v1.33.4"
  MKCERT_VERSION: "v1.4.4"
  NODE_VERSION: "20.19.5"
  OLM_VERSION: "v0.38.0"
  POSTGRESQL_VERSION: "17.6.0-debian-12-r4"
  README_GENERATOR_REPO: "bitnami-labs/readme-generator-for-helm"
  RUST_VERSION: "1.91.1"
  SEMVER_VERSION: "3.4.0"

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      golang_version: ${{ steps.set-outputs.outputs.golang_version }}
      img_modifier: ${{ steps.set-outputs.outputs.img_modifier }}
      img_prefix: ${{ steps.set-outputs.outputs.img_prefix }}
      img_registry: ${{ steps.set-outputs.outputs.img_registry }}
      img_dev_tag: ${{ steps.set-outputs.outputs.img_dev_tag }}
      img_prod_tag: ${{ steps.set-outputs.outputs.img_prod_tag }}
      postgresql_version: ${{ steps.set-outputs.outputs.postgresql_version }}
      rust_version: ${{ steps.set-outputs.outputs.rust_version }}
      running_on_main: ${{ steps.set-outputs.outputs.running_on_main }}
      triggered_from_fork: ${{ steps.set-outputs.outputs.triggered_from_fork }}
    steps:
      - name: Show GitHub event
        env:
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
        run: echo $EVENT_CONTEXT | jq
      - name: Show PR context
        env:
          PR_CONTEXT: ${{ toJSON(github.event.pull_request) }}
        run: echo $PR_CONTEXT | jq
      - name: Set outputs
        id: set-outputs
        env:
          PR_CONTEXT: ${{ toJSON(github.event.pull_request) }}
          PR_SOURCE_REPO_NAME: ${{ github.event.pull_request.head.repo.full_name }}
        run: |

          if [[ "${GITHUB_REPOSITORY}" == "${KUBEAPPS_REPO}" ]]; then
            echo "img_prefix=${IMG_PREFIX}" >> $GITHUB_OUTPUT
          else
            # When running in forks (NOT triggered due to a PR from an external fork, but running the workflow in the
            # external repo), we push the images to a personal dockerhub namespace (or whatever other registry) if configured
            echo "img_prefix=${IMG_PREFIX_FOR_FORKS}" >> $GITHUB_OUTPUT
          fi;

          # Check if the workflow is triggered due to a PR from an external fork
          if [[ ("${PR_CONTEXT}" != "" && "${PR_CONTEXT}" != null) && "${PR_SOURCE_REPO_NAME}" != "${GITHUB_REPOSITORY}" ]]; then
            echo "triggered_from_fork=true" >> $GITHUB_OUTPUT
          else
            echo "triggered_from_fork=false" >> $GITHUB_OUTPUT
          fi

          if [[ ${GITHUB_REF_TYPE} == "tag" ]]; then
            echo "img_prod_tag=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "img_prod_tag=latest" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          fi;

          if [[ ${GITHUB_REF_NAME} == "main" ]]; then
            echo "running_on_main=true" >> $GITHUB_OUTPUT
          else
            echo "running_on_main=false" >> $GITHUB_OUTPUT
          fi

          echo "golang_version=${GOLANG_VERSION}" >> $GITHUB_OUTPUT
          echo "golangci_lint_version=${GOLANGCI_LINT_VERSION}" >> $GITHUB_OUTPUT
          echo "img_modifier=${IMG_MODIFIER}" >> $GITHUB_OUTPUT
          echo "img_registry=${IMG_REGISTRY}" >> $GITHUB_OUTPUT
          echo "img_dev_tag=${IMG_DEV_TAG}" >> $GITHUB_OUTPUT
          echo "postgresql_version=${POSTGRESQL_VERSION}" >> $GITHUB_OUTPUT
          echo "rust_version=${RUST_VERSION}" >> $GITHUB_OUTPUT
      - name: Show outputs
        run: |
          echo "GOLANG_VERSION: ${{steps.set-outputs.outputs.golang_version}}"
          echo "GOLANGCI_LINT_VERSION: ${{steps.set-outputs.outputs.golangci_lint_version}}"
          echo "IMG_MODIFIER: ${{steps.set-outputs.outputs.img_modifier}}"
          echo "IMG_PREFIX: ${{steps.set-outputs.outputs.img_prefix}}"
          echo "IMG_REGISTRY: ${{steps.set-outputs.outputs.img_registry}}"
          echo "IMG_DEV_TAG: ${{steps.set-outputs.outputs.img_dev_tag}}"
          echo "IMG_PROD_TAG: ${{steps.set-outputs.outputs.img_prod_tag}}"
          echo "POSTGRESQL_VERSION: ${{steps.set-outputs.outputs.postgresql_version}}"
          echo "RUST_VERSION: ${{steps.set-outputs.outputs.rust_version}}"
          echo "RUNNING_ON_MAIN: ${{steps.set-outputs.outputs.running_on_main}}"
          echo "TRIGGERED_FROM_FORK: ${{steps.set-outputs.outputs.triggered_from_fork}}"
          echo "VERSION: ${{steps.set-outputs.outputs.version}}"

  linters:
    if: inputs.run_linters && github.ref_name != 'enable_basic_github_actions'
    needs:
      - setup
    uses: ./.github/workflows/linters.yml
    with:
      golang_version: ${{ needs.setup.outputs.golang_version }}
      golangci_lint_version: ${{ needs.setup.outputs.golangci_lint_version }}

  linters_result:
    if: inputs.run_linters && github.ref_name != 'enable_basic_github_actions' && always()
    needs: linters
    runs-on: ubuntu-latest
    steps:
      - name: "Check all linters result"
        if: needs.linters.result != 'success'
        run: exit 1

  test_go:
    needs:
      - setup
    runs-on: ubuntu-latest
    services:
      postgresql:
        image: ghcr.io/sap/kubeapps/bitnami-deprecated-postgresql:${{needs.setup.outputs.postgresql_version}}
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 10s
          --health-retries 10
        ports:
          - 5432:5432
        env:
          ALLOW_EMPTY_PASSWORD: "yes"
    steps:
      - uses: actions/checkout@v5
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GOLANG_VERSION }}
      - name: Run go unit tests
        run: make test
      - run: make test-db

  test_dashboard:
    runs-on: ubuntu-latest
    needs:
      - setup
    env:
      # Note that the max old space setting is per worker, so running the tests
      # with 4 workers on a 7Gb (free plan) needs 1.75Gb of max old space. Forcing
      # garbage collection to start earlier with 1024M per worker.
      # See https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources
      NODE_OPTIONS: "--max-old-space-size=1024"
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: Install dashboard dependencies
        run: yarn install --cwd=dashboard --frozen-lockfile
      - name: Run dashboard linter
        run: yarn --cwd=dashboard run lint
      - name: Run dashboard unit tests
        run: yarn --cwd=dashboard run test --maxWorkers=4 --coverage --logHeapUsage

  test_pinniped_proxy:
    needs:
      - setup
    runs-on: ubuntu-latest
    container:
      image: rust:${{needs.setup.outputs.rust_version}}
    steps:
      - uses: actions/checkout@v5
      - name: Run rust unit tests
        run: cargo test --manifest-path cmd/pinniped-proxy/Cargo.toml

  test_oci_catalog:
    needs:
      - setup
    runs-on: ubuntu-latest
    container:
      image: rust:${{needs.setup.outputs.rust_version}}
    steps:
      - uses: actions/checkout@v5
      - name: Install protoc dependency
        run: |
          apt-get update -y
          apt-get install -y protobuf-compiler
      - name: Run rust unit tests
        run: cargo test --manifest-path cmd/oci-catalog/Cargo.toml

  test_chart_render:
    needs:
      - setup
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GOLANG_VERSION }}
      - name: "Install helm (minimum and stable)"
        run: |
          set -eu
          source ./script/lib/libcitools.sh
          installHelm ${HELM_VERSION_MIN}
          installHelm ${HELM_VERSION_STABLE} helm-stable
      - name: Run chart template test
        run: ./script/chart-template-test.sh

  build_docker_images:
    name: "Build ${{matrix.image}} image"
    needs:
      - setup
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        image:
          - apprepository-controller
          - asset-syncer
          - kubeapps-apis
          - pinniped-proxy
          - oci-catalog
    steps:
      - id: setup
        run: |
          echo "img_name=${{matrix.image}}" >> $GITHUB_OUTPUT
          echo "img_file=/tmp/${{matrix.image}}-image.tar" >> $GITHUB_OUTPUT
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ${{needs.setup.outputs.img_prefix}}${{steps.setup.outputs.img_name}}${{needs.setup.outputs.img_modifier}}
          flavor: latest=true
          tags: ${{needs.setup.outputs.img_dev_tag}}
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - name: Build image
        uses: docker/build-push-action@v6
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false
        with:
          file: cmd/${{matrix.image}}/Dockerfile
          platforms: ${{ env.IMG_PLATFORMS }}
          tags: ${{ steps.meta.outputs.tags }}
          build-args: ${{ needs.setup.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=${{ steps.setup.outputs.img_file }}
      - name: Upload image
        uses: actions/upload-artifact@v4
        with:
          name: ${{matrix.image}}-image
          path: ${{ steps.setup.outputs.img_file }}

  build_dashboard_image:
    name: "Build dashboard image"
    needs:
      - setup
    runs-on: ubuntu-latest
    env:
      IMG_NAME: dashboard
    steps:
      - id: setup
        run: |
          echo "img_name=${IMG_NAME}" >> $GITHUB_OUTPUT
          echo "img_file=/tmp/${IMG_NAME}-image.tar" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v5
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ${{needs.setup.outputs.img_prefix}}${{steps.setup.outputs.img_name}}${{needs.setup.outputs.img_modifier}}
          flavor: latest=true
          tags: ${{needs.setup.outputs.img_dev_tag}}
      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3
      - name: Build image
        uses: docker/build-push-action@v6
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false
        with:
          context: dashboard
          platforms: ${{ env.IMG_PLATFORMS }}
          tags: ${{ steps.meta.outputs.tags }}
          build-args: ${{ needs.setup.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=${{ steps.setup.outputs.img_file }}
      - name: Upload image
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.setup.outputs.img_name }}-image
          path: ${{ steps.setup.outputs.img_file }}

  build_e2e_runner_image:
    name: "Build E2E runner image"
    needs:
      - setup
    runs-on: ubuntu-latest
    env:
      IMG_NAME: integration-tests
    steps:
      - id: setup
        run: |
          echo "img_name=${IMG_NAME}" >> $GITHUB_OUTPUT
          echo "img_file=/tmp/${IMG_NAME}-image.tar" >> $GITHUB_OUTPUT
      - uses: actions/checkout@v5
      - uses: docker/metadata-action@v5
        id: meta
        with:
          images: ${{needs.setup.outputs.img_prefix}}${{steps.setup.outputs.img_name}}${{needs.setup.outputs.img_modifier}}
          flavor: latest=true
          tags: ${{needs.setup.outputs.img_dev_tag}}
      - uses: docker/setup-buildx-action@v3
      - name: Build image
        uses: docker/build-push-action@v6
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false
        with:
          context: integration
          # It doesn't make sense investing CI time in making a multiplatform image here
          platforms: linux/amd64
          tags: ${{ steps.meta.outputs.tags }}
          build-args: ${{ needs.setup.outputs.version }}
          outputs: type=docker,dest=${{ steps.setup.outputs.img_file }}
      - name: Upload image
        uses: actions/upload-artifact@v4
        with:
          name: ${{steps.setup.outputs.img_name}}-image
          path: ${{ steps.setup.outputs.img_file }}

  # Push images to ghcr.io/sap/[image]-ci:[dev-tag]
  push_dev_images:
    # If the workflow is triggered from a PR from an external fork, secrets won't be available, so we cannot log into ghcr
    if: needs.setup.outputs.triggered_from_fork == 'false'
    runs-on: ubuntu-latest
    needs:
      - setup
      - build_docker_images
      - build_dashboard_image
      - build_e2e_runner_image
    env:
      ADDITIONAL_IMAGES_TO_PUSH: integration-tests
      IMG_PREFIX: ${{ needs.setup.outputs.img_prefix }}
      IMG_MODIFIER: ${{ needs.setup.outputs.img_modifier }}
      IMG_DEV_TAG: ${{ needs.setup.outputs.img_dev_tag }}
      IMG_REGISTRY: ${{ needs.setup.outputs.img_registry }}
    steps:
      - run: echo "IMAGES_TO_PUSH=\"${IMAGES_TO_PUSH} ${ADDITIONAL_IMAGES_TO_PUSH}\"" >> $GITHUB_ENV
      - name: Login to GitHub Container Registry (ghcr.io)
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Download built images
        uses: actions/download-artifact@v5
      - name: Load, retag and push images
        run: |
          set -eu
          for artifact in *; do
            echo "::debug::Processing artifact '${artifact}'"

            if [[ "${artifact}" != *"-image" ]]; then
              echo "::notice ::Skipping artifact ${artifact}, it's not a container image"
              continue
            fi

            image=${artifact/-image/}
            if [[ "${IMAGES_TO_PUSH}" != *"${image}"* ]]; then
              echo "::notice ::Skipping image ${image}, it's not an image to push"
              continue
            fi

            echo "::notice ::Loading image ${image}"
            docker load --input "${artifact}/${artifact}.tar"

            # Original image tag (as built)
            original_image=${IMG_PREFIX}${image}${IMG_MODIFIER}:${IMG_DEV_TAG}

            # New image tag for ghcr.io (IMG_PREFIX already contains sap/kubeapps/)
            ghcr_image=${IMG_REGISTRY}/${IMG_PREFIX}${image}${IMG_MODIFIER}:${IMG_DEV_TAG}

            echo "::notice ::Retagging image from ${original_image} to ${ghcr_image}"
            docker tag ${original_image} ${ghcr_image}

            echo "::notice ::Pushing image ${ghcr_image}"
            docker push ${ghcr_image}
          done


  local_e2e_tests:
    needs:
      - setup
      - test_go
      - test_dashboard
      - test_pinniped_proxy
      - test_oci_catalog
      - test_chart_render
      - build_docker_images
      - build_dashboard_image
      - build_e2e_runner_image
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tests_group:
          - flux
          - main-group-1
          - main-group-2
          - main-group-3
          - multicluster
          - multicluster-nokubeapps
          - operators
    env:
      DEFAULT_DEX_IP: "172.18.0.2"
      IMG_PREFIX: ${{ needs.setup.outputs.img_prefix }}
      TESTS_GROUP: ${{ matrix.tests_group }}
      TEST_OPERATORS: "1"
      TEST_UPGRADE: "1"
      TEST_TIMEOUT_MINUTES: 6  # Timeout minutes for each test
      USE_MULTICLUSTER_OIDC_ENV: "true"
    steps:
      - uses: actions/checkout@v5
      - name: "Install required CLI tools"
        run: |
          set -eu
          source ./script/lib/libcitools.sh

          installKind ${KIND_VERSION}
          installKubectl ${KUBECTL_VERSION}
          installMkcert ${MKCERT_VERSION}
          installHelm ${HELM_VERSION_MIN}
          installHelm ${HELM_VERSION_STABLE} helm-stable
      - name: "Spin up Kind cluster"
        run: |
          set -eu
          DEFAULT_DEX_IP=${DEFAULT_DEX_IP} K8S_KIND_VERSION=${K8S_KIND_VERSION} ./script/create-kind-cluster.sh
      - name: "Copy apiserver certificates"
        run: |
          set -eu
          # dex will be running on the same node as the API server in the dev environment, so we can reuse the key and cert from the apiserver
          docker cp kubeapps-ci-control-plane:/etc/kubernetes/pki/apiserver.crt ./devel/dex.crt
          docker cp kubeapps-ci-control-plane:/etc/kubernetes/pki/apiserver.key ./devel/dex.key
          sudo chown $(whoami) ./devel/dex.key
          sudo chown $(whoami) ./devel/dex.crt
      - name: "Install additional cluster"
        run: |
          set -eu
          DEFAULT_DEX_IP=${DEFAULT_DEX_IP} K8S_KIND_VERSION=${K8S_KIND_VERSION} ./script/create-additional-kind-cluster.sh
      - name: "Export cluster variables"
        run: |
          set -eu
          DEX_IP=`docker network inspect kind | jq -r '.[0].IPAM.Config[] | select(.Gateway) | .Gateway' | awk -F. '{ print $1"."$2"."$3"."$4+1 }'`
          ADDITIONAL_CLUSTER_IP=`docker network inspect kind | jq -r '.[0].IPAM.Config[] | select(.Gateway) | .Gateway' | awk -F. '{ print $1"."$2"."$3"."$4+2 }'`

          echo DEFAULT_DEX_IP=$DEFAULT_DEX_IP
          echo DEX_IP=$DEX_IP
          echo ADDITIONAL_CLUSTER_IP=$ADDITIONAL_CLUSTER_IP

          # If running kubectl without args, use the default "kubeapps-ci" cluster
          cp ${HOME}/.kube/kind-config-kubeapps-ci ${HOME}/.kube/config
          kubectl config set-context kind-kubeapps-ci

          # If the default IP is not the proper one, the multicluster setup will fail
          if [ "$DEFAULT_DEX_IP" != "$DEX_IP" ]; then echo "Default IP does not match with current IP used in Kind"; exit 1; fi

          echo "DEFAULT_DEX_IP=${DEFAULT_DEX_IP}" >> $GITHUB_ENV
          echo "DEX_IP=${DEX_IP}" >> $GITHUB_ENV
          echo "ADDITIONAL_CLUSTER_IP=${ADDITIONAL_CLUSTER_IP}" >> $GITHUB_ENV
      - name: "Load needed images into Kind"
        run: |
          set -eu
          ./script/load-kind-image.sh ghcr.io/sap/kubeapps/bitnami-deprecated-apache:2.4 kubeapps-ci kubeapps-ci-additional &&
          ./script/load-kind-image.sh ghcr.io/sap/kubeapps/bitnami-deprecated-apache:2.4 kubeapps-ci kubeapps-ci-additional &&
          ./script/load-kind-image.sh registry:$DOCKER_REGISTRY_VERSION kubeapps-ci kubeapps-ci-additional
      - name: "Download docker images"
        uses: actions/download-artifact@v4
        with:
          path: /tmp/images
      - name: "Load CI images in the cluster"
        run: |
          set -eu
          source ./script/lib/liblog.sh
          for path in /tmp/images/*; do
            image=$(basename "$path")
            if [[ "${image}" != *"-image" ]]; then
              echo "::notice ::Skipping artifact ${image}, it's not a docker image"
              continue
            fi
            info "Loading image ${image}"
            kind load image-archive "${path}/${image}.tar" --name kubeapps-ci;
          done
      - name: "Install multicluster deps"
        run: |
          ./script/install-multicluster-deps.sh
      - name: "Run e2e tests script"
        run: ./script/run_e2e_tests.sh
      - name: "Diagnose failure (Kubeapps APIs & PostgreSQL)"
        if: failure()
        run: |
          chmod +x script/diagnose-e2e-failure.sh || true
          ./script/diagnose-e2e-failure.sh kubeapps kubeapps-ci | tee diagnostics-${{ matrix.tests_group }}.log || true
        continue-on-error: true
      - name: 'Upload Diagnostics'
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: diagnostics_${{ matrix.tests_group }}
          path: diagnostics-${{ matrix.tests_group }}.log
      - name: 'Upload Artifacts'
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e_tests_${{ matrix.tests_group }}_reports
          path: integration/reports

  # We need this job to aggregate the result of the local_e2e_tests matrix and summarize it. We don't need it because of
  # GHA itself, but because in GH branch protection rules, we cannot check the status for a job matrix, and would have
  # require the status for each job in the matrix (eg. local_e2e_tests(flux)).
  # See https://github.com/orgs/community/discussions/26822
  local_e2e_tests_result:
    needs:
      - local_e2e_tests
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: "Check local_e2e_tests matrix status"
        if: needs.local_e2e_tests.result != 'success'
        run: exit 1

  push_images:
    if: needs.setup.outputs.running_on_main == 'true' || inputs.trigger_release
    runs-on: ubuntu-latest
    needs:
      - setup
      - local_e2e_tests
    env:
      IMG_PROD_TAG: ${{ needs.setup.outputs.img_prod_tag }}
      IMG_PREFIX: ${{ needs.setup.outputs.img_prefix }}
      IMG_REGISTRY: ${{ needs.setup.outputs.img_registry }}
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: actions/download-artifact@v4
      - run: |
          set -eu
          for artifact in *; do
            echo "::debug::Processing artifact '${artifact}'"

            if [[ "${artifact}" != *"-image" ]]; then
              echo "::notice ::Skipping artifact ${artifact}, it's not a docker image"
              continue
            fi

            image=${artifact/-image/}
            if [[ "${IMAGES_TO_PUSH}" != *"${image}"* ]]; then
              echo "::notice ::Skipping image ${image}, it's not an image to push"
              continue
            fi

            echo "::notice ::Loading image ${image}"
            docker load --input "${artifact}/${artifact}.tar"

            dev_image=${IMG_PREFIX}${image}${IMG_MODIFIER}:${IMG_DEV_TAG}
            prod_image=${IMG_REGISTRY}/${IMG_PREFIX}${image}:${IMG_PROD_TAG}
            docker tag ${dev_image} ${prod_image}

            echo "::notice ::Pushing image ${prod_image}"
            docker push $prod_image
          done

  push_chart:
    if: inputs.trigger_release
    needs:
      - setup
      - local_e2e_tests
    runs-on: ubuntu-latest
    env:
      CHART_DIR: chart/kubeapps
    steps:
      - uses: actions/checkout@v5
      - name: Install Helm
        run: |
          set -eu
          source ./script/lib/libcitools.sh
          installHelm ${HELM_VERSION_STABLE} helm-stable
      - name: Show chart version
        run: |
          set -eu
          grep '^version:' ${CHART_DIR}/Chart.yaml || true
      - name: Login to GHCR (OCI) for Helm
        run: |
          set -eu
          helm registry login ghcr.io --username "${{ github.actor }}" --password "${{ secrets.GITHUB_TOKEN }}"
      - name: Update chart dependencies
        run: |
          set -eu
          helm dependency update ${CHART_DIR}
      - name: Package chart
        run: |
          set -eu
          helm package ${CHART_DIR} --destination /tmp
          ls -l /tmp | grep kubeapps- || true
      - name: Push chart to GHCR
        run: |
          set -eu
          CHART_PACKAGE=$(ls /tmp/kubeapps-*.tgz)
          echo "Pushing ${CHART_PACKAGE} to oci://${CHART_OCI_REPO}"
          helm push "${CHART_PACKAGE}" oci://${CHART_OCI_REPO}
      - name: Upload chart artifact
        uses: actions/upload-artifact@v4
        with:
          name: kubeapps-chart
          path: /tmp/kubeapps-*.tgz

  release:
    if: inputs.trigger_release
    needs:
      - setup
      - push_chart
      - local_e2e_tests
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v5
      - run: |
          set -eu
          source ./script/lib/libcitools.sh
          installGithubCLI ${GITHUB_VERSION}
      - name: Run the create_release script
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -eu
          ./script/create_release.sh "${GITHUB_REF_NAME}" "${KUBEAPPS_REPO}"
