// Copyright 2021-2023 the Kubeapps contributors.
// SPDX-License-Identifier: Apache-2.0

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=none"
// @generated from file kubeappsapis/core/packages/v1alpha1/packages.proto (package kubeappsapis.core.packages.v1alpha1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import type { Any } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_any } from "@bufbuild/protobuf/wkt";
import type { Plugin } from "../../plugins/v1alpha1/plugins_pb";
import { file_kubeappsapis_core_plugins_v1alpha1_plugins } from "../../plugins/v1alpha1/plugins_pb";
import { file_protoc_gen_openapiv2_options_annotations } from "../../../../protoc-gen-openapiv2/options/annotations_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file kubeappsapis/core/packages/v1alpha1/packages.proto.
 */
export const file_kubeappsapis_core_packages_v1alpha1_packages: GenFile =
  /*@__PURE__*/
  fileDesc(
    "CjJrdWJlYXBwc2FwaXMvY29yZS9wYWNrYWdlcy92MWFscGhhMS9wYWNrYWdlcy5wcm90bxIja3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEihAIKI0dldEF2YWlsYWJsZVBhY2thZ2VTdW1tYXJpZXNSZXF1ZXN0Ej0KB2NvbnRleHQYASABKAsyLC5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5Db250ZXh0EkoKDmZpbHRlcl9vcHRpb25zGAIgASgLMjIua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuRmlsdGVyT3B0aW9ucxJSChJwYWdpbmF0aW9uX29wdGlvbnMYAyABKAsyNi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5QYWdpbmF0aW9uT3B0aW9ucyKWAQogR2V0QXZhaWxhYmxlUGFja2FnZURldGFpbFJlcXVlc3QSXQoVYXZhaWxhYmxlX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQXZhaWxhYmxlUGFja2FnZVJlZmVyZW5jZRITCgtwa2dfdmVyc2lvbhgCIAEoCSKYAQoiR2V0QXZhaWxhYmxlUGFja2FnZVZlcnNpb25zUmVxdWVzdBJdChVhdmFpbGFibGVfcGFja2FnZV9yZWYYASABKAsyPi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5BdmFpbGFibGVQYWNrYWdlUmVmZXJlbmNlEhMKC3BrZ192ZXJzaW9uGAIgASgJIpkBCiNHZXRBdmFpbGFibGVQYWNrYWdlTWV0YWRhdGFzUmVxdWVzdBJdChVhdmFpbGFibGVfcGFja2FnZV9yZWYYASABKAsyPi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5BdmFpbGFibGVQYWNrYWdlUmVmZXJlbmNlEhMKC3BrZ192ZXJzaW9uGAIgASgJIrgBCiNHZXRJbnN0YWxsZWRQYWNrYWdlU3VtbWFyaWVzUmVxdWVzdBI9Cgdjb250ZXh0GAEgASgLMiwua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQ29udGV4dBJSChJwYWdpbmF0aW9uX29wdGlvbnMYAiABKAsyNi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5QYWdpbmF0aW9uT3B0aW9ucyKBAQogR2V0SW5zdGFsbGVkUGFja2FnZURldGFpbFJlcXVlc3QSXQoVaW5zdGFsbGVkX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZSKUAwodQ3JlYXRlSW5zdGFsbGVkUGFja2FnZVJlcXVlc3QSXQoVYXZhaWxhYmxlX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQXZhaWxhYmxlUGFja2FnZVJlZmVyZW5jZRJECg50YXJnZXRfY29udGV4dBgCIAEoCzIsLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkNvbnRleHQSDAoEbmFtZRgDIAEoCRJUChVwa2dfdmVyc2lvbl9yZWZlcmVuY2UYBCABKAsyNS5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5WZXJzaW9uUmVmZXJlbmNlEg4KBnZhbHVlcxgFIAEoCRJaChZyZWNvbmNpbGlhdGlvbl9vcHRpb25zGAYgASgLMjoua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuUmVjb25jaWxpYXRpb25PcHRpb25zIsACCh1VcGRhdGVJbnN0YWxsZWRQYWNrYWdlUmVxdWVzdBJdChVpbnN0YWxsZWRfcGFja2FnZV9yZWYYASABKAsyPi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5JbnN0YWxsZWRQYWNrYWdlUmVmZXJlbmNlElQKFXBrZ192ZXJzaW9uX3JlZmVyZW5jZRgCIAEoCzI1Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlZlcnNpb25SZWZlcmVuY2USDgoGdmFsdWVzGAMgASgJEloKFnJlY29uY2lsaWF0aW9uX29wdGlvbnMYBCABKAsyOi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5SZWNvbmNpbGlhdGlvbk9wdGlvbnMifgodRGVsZXRlSW5zdGFsbGVkUGFja2FnZVJlcXVlc3QSXQoVaW5zdGFsbGVkX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZSKHAQomR2V0SW5zdGFsbGVkUGFja2FnZVJlc291cmNlUmVmc1JlcXVlc3QSXQoVaW5zdGFsbGVkX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZSK2AQokR2V0QXZhaWxhYmxlUGFja2FnZVN1bW1hcmllc1Jlc3BvbnNlEmEKG2F2YWlsYWJsZV9wYWNrYWdlX3N1bW1hcmllcxgBIAMoCzI8Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkF2YWlsYWJsZVBhY2thZ2VTdW1tYXJ5EhcKD25leHRfcGFnZV90b2tlbhgCIAEoCRISCgpjYXRlZ29yaWVzGAMgAygJIoIBCiFHZXRBdmFpbGFibGVQYWNrYWdlRGV0YWlsUmVzcG9uc2USXQoYYXZhaWxhYmxlX3BhY2thZ2VfZGV0YWlsGAEgASgLMjsua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQXZhaWxhYmxlUGFja2FnZURldGFpbCJ7CiNHZXRBdmFpbGFibGVQYWNrYWdlVmVyc2lvbnNSZXNwb25zZRJUChRwYWNrYWdlX2FwcF92ZXJzaW9ucxgBIAMoCzI2Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlBhY2thZ2VBcHBWZXJzaW9uItUBCiRHZXRBdmFpbGFibGVQYWNrYWdlTWV0YWRhdGFzUmVzcG9uc2USXQoVYXZhaWxhYmxlX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQXZhaWxhYmxlUGFja2FnZVJlZmVyZW5jZRJOChBwYWNrYWdlX21ldGFkYXRhGAIgAygLMjQua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuUGFja2FnZU1ldGFkYXRhIqIBCiRHZXRJbnN0YWxsZWRQYWNrYWdlU3VtbWFyaWVzUmVzcG9uc2USYQobaW5zdGFsbGVkX3BhY2thZ2Vfc3VtbWFyaWVzGAEgAygLMjwua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVN1bW1hcnkSFwoPbmV4dF9wYWdlX3Rva2VuGAIgASgJIoIBCiFHZXRJbnN0YWxsZWRQYWNrYWdlRGV0YWlsUmVzcG9uc2USXQoYaW5zdGFsbGVkX3BhY2thZ2VfZGV0YWlsGAEgASgLMjsua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZURldGFpbCJ/Ch5DcmVhdGVJbnN0YWxsZWRQYWNrYWdlUmVzcG9uc2USXQoVaW5zdGFsbGVkX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZSJ/Ch5VcGRhdGVJbnN0YWxsZWRQYWNrYWdlUmVzcG9uc2USXQoVaW5zdGFsbGVkX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZSIgCh5EZWxldGVJbnN0YWxsZWRQYWNrYWdlUmVzcG9uc2UisQEKJ0dldEluc3RhbGxlZFBhY2thZ2VSZXNvdXJjZVJlZnNSZXNwb25zZRI9Cgdjb250ZXh0GAEgASgLMiwua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQ29udGV4dBJHCg1yZXNvdXJjZV9yZWZzGAIgAygLMjAua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuUmVzb3VyY2VSZWYirQIKF0F2YWlsYWJsZVBhY2thZ2VTdW1tYXJ5El0KFWF2YWlsYWJsZV9wYWNrYWdlX3JlZhgBIAEoCzI+Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkF2YWlsYWJsZVBhY2thZ2VSZWZlcmVuY2USDAoEbmFtZRgCIAEoCRJOCg5sYXRlc3RfdmVyc2lvbhgDIAEoCzI2Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlBhY2thZ2VBcHBWZXJzaW9uEhAKCGljb25fdXJsGAQgASgJEhQKDGRpc3BsYXlfbmFtZRgFIAEoCRIZChFzaG9ydF9kZXNjcmlwdGlvbhgGIAEoCRISCgpjYXRlZ29yaWVzGAcgAygJIucFChZBdmFpbGFibGVQYWNrYWdlRGV0YWlsEl0KFWF2YWlsYWJsZV9wYWNrYWdlX3JlZhgBIAEoCzI+Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkF2YWlsYWJsZVBhY2thZ2VSZWZlcmVuY2USDAoEbmFtZRgCIAEoCRJHCgd2ZXJzaW9uGAMgASgLMjYua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuUGFja2FnZUFwcFZlcnNpb24SEAoIcmVwb191cmwYBCABKAkSEAoIaG9tZV91cmwYBSABKAkSEAoIaWNvbl91cmwYBiABKAkSFAoMZGlzcGxheV9uYW1lGAcgASgJEhkKEXNob3J0X2Rlc2NyaXB0aW9uGAggASgJEhgKEGxvbmdfZGVzY3JpcHRpb24YCSABKAkSDgoGcmVhZG1lGAogASgJEhYKDmRlZmF1bHRfdmFsdWVzGAsgASgJEnsKGWFkZGl0aW9uYWxfZGVmYXVsdF92YWx1ZXMYESADKAsyWC5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5BdmFpbGFibGVQYWNrYWdlRGV0YWlsLkFkZGl0aW9uYWxEZWZhdWx0VmFsdWVzRW50cnkSFQoNdmFsdWVzX3NjaGVtYRgMIAEoCRITCgtzb3VyY2VfdXJscxgNIAMoCRJECgttYWludGFpbmVycxgOIAMoCzIvLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLk1haW50YWluZXISEgoKY2F0ZWdvcmllcxgPIAMoCRIrCg1jdXN0b21fZGV0YWlsGBAgASgLMhQuZ29vZ2xlLnByb3RvYnVmLkFueRo+ChxBZGRpdGlvbmFsRGVmYXVsdFZhbHVlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEi6gQKF0luc3RhbGxlZFBhY2thZ2VTdW1tYXJ5El0KFWluc3RhbGxlZF9wYWNrYWdlX3JlZhgBIAEoCzI+Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkluc3RhbGxlZFBhY2thZ2VSZWZlcmVuY2USDAoEbmFtZRgCIAEoCRJUChVwa2dfdmVyc2lvbl9yZWZlcmVuY2UYAyABKAsyNS5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5WZXJzaW9uUmVmZXJlbmNlEk8KD2N1cnJlbnRfdmVyc2lvbhgEIAEoCzI2Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlBhY2thZ2VBcHBWZXJzaW9uEhAKCGljb25fdXJsGAUgASgJEhgKEHBrZ19kaXNwbGF5X25hbWUYBiABKAkSGQoRc2hvcnRfZGVzY3JpcHRpb24YByABKAkSVwoXbGF0ZXN0X21hdGNoaW5nX3ZlcnNpb24YCCABKAsyNi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5QYWNrYWdlQXBwVmVyc2lvbhJOCg5sYXRlc3RfdmVyc2lvbhgJIAEoCzI2Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlBhY2thZ2VBcHBWZXJzaW9uEksKBnN0YXR1cxgKIAEoCzI7Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkluc3RhbGxlZFBhY2thZ2VTdGF0dXMiwwYKFkluc3RhbGxlZFBhY2thZ2VEZXRhaWwSXQoVaW5zdGFsbGVkX3BhY2thZ2VfcmVmGAEgASgLMj4ua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZRJUChVwa2dfdmVyc2lvbl9yZWZlcmVuY2UYAiABKAsyNS5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5WZXJzaW9uUmVmZXJlbmNlEgwKBG5hbWUYAyABKAkSTwoPY3VycmVudF92ZXJzaW9uGAQgASgLMjYua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuUGFja2FnZUFwcFZlcnNpb24SFgoOdmFsdWVzX2FwcGxpZWQYBSABKAkSWgoWcmVjb25jaWxpYXRpb25fb3B0aW9ucxgGIAEoCzI6Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlJlY29uY2lsaWF0aW9uT3B0aW9ucxJLCgZzdGF0dXMYByABKAsyOy5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5JbnN0YWxsZWRQYWNrYWdlU3RhdHVzEh8KF3Bvc3RfaW5zdGFsbGF0aW9uX25vdGVzGAggASgJEl0KFWF2YWlsYWJsZV9wYWNrYWdlX3JlZhgJIAEoCzI+Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkF2YWlsYWJsZVBhY2thZ2VSZWZlcmVuY2USVwoXbGF0ZXN0X21hdGNoaW5nX3ZlcnNpb24YCiABKAsyNi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5QYWNrYWdlQXBwVmVyc2lvbhJOCg5sYXRlc3RfdmVyc2lvbhgLIAEoCzI2Lmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLlBhY2thZ2VBcHBWZXJzaW9uEisKDWN1c3RvbV9kZXRhaWwYDiABKAsyFC5nb29nbGUucHJvdG9idWYuQW55Ii0KB0NvbnRleHQSDwoHY2x1c3RlchgBIAEoCRIRCgluYW1lc3BhY2UYAiABKAkiqgEKGUF2YWlsYWJsZVBhY2thZ2VSZWZlcmVuY2USPQoHY29udGV4dBgBIAEoCzIsLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkNvbnRleHQSEgoKaWRlbnRpZmllchgCIAEoCRI6CgZwbHVnaW4YAyABKAsyKi5rdWJlYXBwc2FwaXMuY29yZS5wbHVnaW5zLnYxYWxwaGExLlBsdWdpbiIpCgpNYWludGFpbmVyEgwKBG5hbWUYASABKAkSDQoFZW1haWwYAiABKAkicgoNRmlsdGVyT3B0aW9ucxINCgVxdWVyeRgBIAEoCRISCgpjYXRlZ29yaWVzGAIgAygJEhQKDHJlcG9zaXRvcmllcxgDIAMoCRITCgtwa2dfdmVyc2lvbhgEIAEoCRITCgthcHBfdmVyc2lvbhgFIAEoCSI6ChFQYWdpbmF0aW9uT3B0aW9ucxISCgpwYWdlX3Rva2VuGAEgASgJEhEKCXBhZ2Vfc2l6ZRgCIAEoBSKqAQoZSW5zdGFsbGVkUGFja2FnZVJlZmVyZW5jZRI9Cgdjb250ZXh0GAEgASgLMiwua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQ29udGV4dBISCgppZGVudGlmaWVyGAIgASgJEjoKBnBsdWdpbhgDIAEoCzIqLmt1YmVhcHBzYXBpcy5jb3JlLnBsdWdpbnMudjFhbHBoYTEuUGx1Z2luIiMKEFZlcnNpb25SZWZlcmVuY2USDwoHdmVyc2lvbhgBIAEoCSK3AgoWSW5zdGFsbGVkUGFja2FnZVN0YXR1cxINCgVyZWFkeRgBIAEoCBJYCgZyZWFzb24YAiABKA4ySC5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5JbnN0YWxsZWRQYWNrYWdlU3RhdHVzLlN0YXR1c1JlYXNvbhITCgt1c2VyX3JlYXNvbhgDIAEoCSKeAQoMU3RhdHVzUmVhc29uEh0KGVNUQVRVU19SRUFTT05fVU5TUEVDSUZJRUQQABIbChdTVEFUVVNfUkVBU09OX0lOU1RBTExFRBABEh0KGVNUQVRVU19SRUFTT05fVU5JTlNUQUxMRUQQAhIYChRTVEFUVVNfUkVBU09OX0ZBSUxFRBADEhkKFVNUQVRVU19SRUFTT05fUEVORElORxAEIlgKFVJlY29uY2lsaWF0aW9uT3B0aW9ucxIQCghpbnRlcnZhbBgBIAEoCRIPCgdzdXNwZW5kGAIgASgIEhwKFHNlcnZpY2VfYWNjb3VudF9uYW1lGAMgASgJIj0KEVBhY2thZ2VBcHBWZXJzaW9uEhMKC3BrZ192ZXJzaW9uGAEgASgJEhMKC2FwcF92ZXJzaW9uGAIgASgJInwKD1BhY2thZ2VNZXRhZGF0YRISCgptZWRpYV90eXBlGAEgASgJEhUKDWFydGlmYWN0X3R5cGUYAiABKAkSDgoGZGlnZXN0GAMgASgJEgwKBG5hbWUYBCABKAkSEwoLZGVzY3JpcHRpb24YBSABKAkSCwoDdXJsGAYgASgJIlEKC1Jlc291cmNlUmVmEhMKC2FwaV92ZXJzaW9uGAEgASgJEgwKBGtpbmQYAiABKAkSDAoEbmFtZRgDIAEoCRIRCgluYW1lc3BhY2UYBCABKAkywB0KD1BhY2thZ2VzU2VydmljZRLmAQocR2V0QXZhaWxhYmxlUGFja2FnZVN1bW1hcmllcxJILmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkdldEF2YWlsYWJsZVBhY2thZ2VTdW1tYXJpZXNSZXF1ZXN0Gkkua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuR2V0QXZhaWxhYmxlUGFja2FnZVN1bW1hcmllc1Jlc3BvbnNlIjGC0+STAisSKS9jb3JlL3BhY2thZ2VzL3YxYWxwaGExL2F2YWlsYWJsZXBhY2thZ2VzEq8DChlHZXRBdmFpbGFibGVQYWNrYWdlRGV0YWlsEkUua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuR2V0QXZhaWxhYmxlUGFja2FnZURldGFpbFJlcXVlc3QaRi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5HZXRBdmFpbGFibGVQYWNrYWdlRGV0YWlsUmVzcG9uc2UiggKC0+STAvsBEvgBL2NvcmUvcGFja2FnZXMvdjFhbHBoYTEvYXZhaWxhYmxlcGFja2FnZXMvcGx1Z2luL3thdmFpbGFibGVfcGFja2FnZV9yZWYucGx1Z2luLm5hbWV9L3thdmFpbGFibGVfcGFja2FnZV9yZWYucGx1Z2luLnZlcnNpb259L2Mve2F2YWlsYWJsZV9wYWNrYWdlX3JlZi5jb250ZXh0LmNsdXN0ZXJ9L25zL3thdmFpbGFibGVfcGFja2FnZV9yZWYuY29udGV4dC5uYW1lc3BhY2V9L3thdmFpbGFibGVfcGFja2FnZV9yZWYuaWRlbnRpZmllcj0qKn0SvgMKG0dldEF2YWlsYWJsZVBhY2thZ2VWZXJzaW9ucxJHLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkdldEF2YWlsYWJsZVBhY2thZ2VWZXJzaW9uc1JlcXVlc3QaSC5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5HZXRBdmFpbGFibGVQYWNrYWdlVmVyc2lvbnNSZXNwb25zZSKLAoLT5JMChAISgQIvY29yZS9wYWNrYWdlcy92MWFscGhhMS9hdmFpbGFibGVwYWNrYWdlcy9wbHVnaW4ve2F2YWlsYWJsZV9wYWNrYWdlX3JlZi5wbHVnaW4ubmFtZX0ve2F2YWlsYWJsZV9wYWNrYWdlX3JlZi5wbHVnaW4udmVyc2lvbn0vYy97YXZhaWxhYmxlX3BhY2thZ2VfcmVmLmNvbnRleHQuY2x1c3Rlcn0vbnMve2F2YWlsYWJsZV9wYWNrYWdlX3JlZi5jb250ZXh0Lm5hbWVzcGFjZX0ve2F2YWlsYWJsZV9wYWNrYWdlX3JlZi5pZGVudGlmaWVyPSoqfS92ZXJzaW9ucxLBAwocR2V0QXZhaWxhYmxlUGFja2FnZU1ldGFkYXRhcxJILmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkdldEF2YWlsYWJsZVBhY2thZ2VNZXRhZGF0YXNSZXF1ZXN0Gkkua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuR2V0QXZhaWxhYmxlUGFja2FnZU1ldGFkYXRhc1Jlc3BvbnNlIosCgtPkkwKEAhKBAi9jb3JlL3BhY2thZ2VzL3YxYWxwaGExL2F2YWlsYWJsZXBhY2thZ2VzL3BsdWdpbi97YXZhaWxhYmxlX3BhY2thZ2VfcmVmLnBsdWdpbi5uYW1lfS97YXZhaWxhYmxlX3BhY2thZ2VfcmVmLnBsdWdpbi52ZXJzaW9ufS9jL3thdmFpbGFibGVfcGFja2FnZV9yZWYuY29udGV4dC5jbHVzdGVyfS9ucy97YXZhaWxhYmxlX3BhY2thZ2VfcmVmLmNvbnRleHQubmFtZXNwYWNlfS97YXZhaWxhYmxlX3BhY2thZ2VfcmVmLmlkZW50aWZpZXI9Kip9L21ldGFkYXRhEuYBChxHZXRJbnN0YWxsZWRQYWNrYWdlU3VtbWFyaWVzEkgua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuR2V0SW5zdGFsbGVkUGFja2FnZVN1bW1hcmllc1JlcXVlc3QaSS5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5HZXRJbnN0YWxsZWRQYWNrYWdlU3VtbWFyaWVzUmVzcG9uc2UiMYLT5JMCKxIpL2NvcmUvcGFja2FnZXMvdjFhbHBoYTEvaW5zdGFsbGVkcGFja2FnZXMSrAMKGUdldEluc3RhbGxlZFBhY2thZ2VEZXRhaWwSRS5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5HZXRJbnN0YWxsZWRQYWNrYWdlRGV0YWlsUmVxdWVzdBpGLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkdldEluc3RhbGxlZFBhY2thZ2VEZXRhaWxSZXNwb25zZSL/AYLT5JMC+AES9QEvY29yZS9wYWNrYWdlcy92MWFscGhhMS9pbnN0YWxsZWRwYWNrYWdlcy9wbHVnaW4ve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5wbHVnaW4ubmFtZX0ve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5wbHVnaW4udmVyc2lvbn0vYy97aW5zdGFsbGVkX3BhY2thZ2VfcmVmLmNvbnRleHQuY2x1c3Rlcn0vbnMve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5jb250ZXh0Lm5hbWVzcGFjZX0ve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5pZGVudGlmaWVyfRLXAQoWQ3JlYXRlSW5zdGFsbGVkUGFja2FnZRJCLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkNyZWF0ZUluc3RhbGxlZFBhY2thZ2VSZXF1ZXN0GkMua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuQ3JlYXRlSW5zdGFsbGVkUGFja2FnZVJlc3BvbnNlIjSC0+STAi46ASoiKS9jb3JlL3BhY2thZ2VzL3YxYWxwaGExL2luc3RhbGxlZHBhY2thZ2VzEqYDChZVcGRhdGVJbnN0YWxsZWRQYWNrYWdlEkIua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuVXBkYXRlSW5zdGFsbGVkUGFja2FnZVJlcXVlc3QaQy5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5VcGRhdGVJbnN0YWxsZWRQYWNrYWdlUmVzcG9uc2UiggKC0+STAvsBOgEqGvUBL2NvcmUvcGFja2FnZXMvdjFhbHBoYTEvaW5zdGFsbGVkcGFja2FnZXMvcGx1Z2luL3tpbnN0YWxsZWRfcGFja2FnZV9yZWYucGx1Z2luLm5hbWV9L3tpbnN0YWxsZWRfcGFja2FnZV9yZWYucGx1Z2luLnZlcnNpb259L2Mve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5jb250ZXh0LmNsdXN0ZXJ9L25zL3tpbnN0YWxsZWRfcGFja2FnZV9yZWYuY29udGV4dC5uYW1lc3BhY2V9L3tpbnN0YWxsZWRfcGFja2FnZV9yZWYuaWRlbnRpZmllcn0SowMKFkRlbGV0ZUluc3RhbGxlZFBhY2thZ2USQi5rdWJlYXBwc2FwaXMuY29yZS5wYWNrYWdlcy52MWFscGhhMS5EZWxldGVJbnN0YWxsZWRQYWNrYWdlUmVxdWVzdBpDLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkRlbGV0ZUluc3RhbGxlZFBhY2thZ2VSZXNwb25zZSL/AYLT5JMC+AEq9QEvY29yZS9wYWNrYWdlcy92MWFscGhhMS9pbnN0YWxsZWRwYWNrYWdlcy9wbHVnaW4ve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5wbHVnaW4ubmFtZX0ve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5wbHVnaW4udmVyc2lvbn0vYy97aW5zdGFsbGVkX3BhY2thZ2VfcmVmLmNvbnRleHQuY2x1c3Rlcn0vbnMve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5jb250ZXh0Lm5hbWVzcGFjZX0ve2luc3RhbGxlZF9wYWNrYWdlX3JlZi5pZGVudGlmaWVyfRLLAwofR2V0SW5zdGFsbGVkUGFja2FnZVJlc291cmNlUmVmcxJLLmt1YmVhcHBzYXBpcy5jb3JlLnBhY2thZ2VzLnYxYWxwaGExLkdldEluc3RhbGxlZFBhY2thZ2VSZXNvdXJjZVJlZnNSZXF1ZXN0Gkwua3ViZWFwcHNhcGlzLmNvcmUucGFja2FnZXMudjFhbHBoYTEuR2V0SW5zdGFsbGVkUGFja2FnZVJlc291cmNlUmVmc1Jlc3BvbnNlIowCgtPkkwKFAhKCAi9jb3JlL3BhY2thZ2VzL3YxYWxwaGExL2luc3RhbGxlZHBhY2thZ2VzL3BsdWdpbi97aW5zdGFsbGVkX3BhY2thZ2VfcmVmLnBsdWdpbi5uYW1lfS97aW5zdGFsbGVkX3BhY2thZ2VfcmVmLnBsdWdpbi52ZXJzaW9ufS9jL3tpbnN0YWxsZWRfcGFja2FnZV9yZWYuY29udGV4dC5jbHVzdGVyfS9ucy97aW5zdGFsbGVkX3BhY2thZ2VfcmVmLmNvbnRleHQubmFtZXNwYWNlfS97aW5zdGFsbGVkX3BhY2thZ2VfcmVmLmlkZW50aWZpZXJ9L3Jlc291cmNlcmVmc0JPWk1naXRodWIuY29tL3Ztd2FyZS10YW56dS9rdWJlYXBwcy9jbWQva3ViZWFwcHMtYXBpcy9nZW4vY29yZS9wYWNrYWdlcy92MWFscGhhMWIGcHJvdG8z",
    [
      file_google_api_annotations,
      file_google_protobuf_any,
      file_kubeappsapis_core_plugins_v1alpha1_plugins,
      file_protoc_gen_openapiv2_options_annotations,
    ],
  );

/**
 * GetAvailablePackageSummariesRequest
 *
 * Request for GetAvailablePackageSummaries
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageSummariesRequest
 */
export type GetAvailablePackageSummariesRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageSummariesRequest"> & {
    /**
     * The context (cluster/namespace) for the request
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
     */
    context?: Context;

    /**
     * The filters used for the request
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.FilterOptions filter_options = 2;
     */
    filterOptions?: FilterOptions;

    /**
     * Pagination options specifying where to start and how many results to include.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PaginationOptions pagination_options = 3;
     */
    paginationOptions?: PaginationOptions;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageSummariesRequest.
 * Use `create(GetAvailablePackageSummariesRequestSchema)` to create a new message.
 */
export const GetAvailablePackageSummariesRequestSchema: GenMessage<GetAvailablePackageSummariesRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 0);

/**
 * GetAvailablePackageDetailRequest
 *
 * Request for GetAvailablePackageDetail
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageDetailRequest
 */
export type GetAvailablePackageDetailRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageDetailRequest"> & {
    /**
     * The information required to uniquely
     * identify an available package
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * Optional specific version (or version reference) to request.
     * By default the latest version (or latest version matching the reference)
     * will be returned.
     *
     * @generated from field: string pkg_version = 2;
     */
    pkgVersion: string;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageDetailRequest.
 * Use `create(GetAvailablePackageDetailRequestSchema)` to create a new message.
 */
export const GetAvailablePackageDetailRequestSchema: GenMessage<GetAvailablePackageDetailRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 1);

/**
 * GetAvailablePackageVersionsRequest
 *
 * Request for GetAvailablePackageVersions
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageVersionsRequest
 */
export type GetAvailablePackageVersionsRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageVersionsRequest"> & {
    /**
     * The information required to uniquely
     * identify an available package
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * Optional version reference for which full version history is required.  By
     * default a summary of versions is returned as outlined in the response.
     * Plugins can choose not to implement this and provide the summary only, it
     * is provided for completeness only.
     *
     * @generated from field: string pkg_version = 2;
     */
    pkgVersion: string;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageVersionsRequest.
 * Use `create(GetAvailablePackageVersionsRequestSchema)` to create a new message.
 */
export const GetAvailablePackageVersionsRequestSchema: GenMessage<GetAvailablePackageVersionsRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 2);

/**
 * GetAvailablePackageMetadatasRequest
 *
 * Request for GetAvailablePackageMetadatas
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageMetadatasRequest
 */
export type GetAvailablePackageMetadatasRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageMetadatasRequest"> & {
    /**
     * Available Package Reference
     *
     * Identifies the available package for which we are requesting
     * the metadata.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * Package Version
     *
     * Version reference for which metadata is requested.
     *
     * @generated from field: string pkg_version = 2;
     */
    pkgVersion: string;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageMetadatasRequest.
 * Use `create(GetAvailablePackageMetadatasRequestSchema)` to create a new message.
 */
export const GetAvailablePackageMetadatasRequestSchema: GenMessage<GetAvailablePackageMetadatasRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 3);

/**
 * GetInstalledPackageSummariesRequest
 *
 * Request for GetInstalledPackageSummaries
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageSummariesRequest
 */
export type GetInstalledPackageSummariesRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetInstalledPackageSummariesRequest"> & {
    /**
     * The context (cluster/namespace) for the request.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
     */
    context?: Context;

    /**
     * Pagination options specifying where to start and how many results to include.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PaginationOptions pagination_options = 2;
     */
    paginationOptions?: PaginationOptions;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageSummariesRequest.
 * Use `create(GetInstalledPackageSummariesRequestSchema)` to create a new message.
 */
export const GetInstalledPackageSummariesRequestSchema: GenMessage<GetInstalledPackageSummariesRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 4);

/**
 * GetInstalledPackageDetailRequest
 *
 * Request for GetInstalledPackageDetail
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageDetailRequest
 */
export type GetInstalledPackageDetailRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetInstalledPackageDetailRequest"> & {
    /**
     * The information required to uniquely
     * identify an installed package
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageDetailRequest.
 * Use `create(GetInstalledPackageDetailRequestSchema)` to create a new message.
 */
export const GetInstalledPackageDetailRequestSchema: GenMessage<GetInstalledPackageDetailRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 5);

/**
 * CreateInstalledPackageRequest
 *
 * Request for CreateInstalledPackage
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.CreateInstalledPackageRequest
 */
export type CreateInstalledPackageRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.CreateInstalledPackageRequest"> & {
    /**
     * A reference uniquely identifying the package available for installation.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * The target context where the package is intended to be installed.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.Context target_context = 2;
     */
    targetContext?: Context;

    /**
     * A user-provided name for the installed package (eg. project-x-db)
     *
     * @generated from field: string name = 3;
     */
    name: string;

    /**
     * For helm this will be the exact version in VersionReference.version
     * For other plugins we can extend the VersionReference as needed.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.VersionReference pkg_version_reference = 4;
     */
    pkgVersionReference?: VersionReference;

    /**
     * An optional serialized values string to be included when templating a package
     * in the format expected by the plugin. Included when the backend format doesn't
     * use secrets or configmaps for values or supports both. These values are layered
     * on top of any values refs above, when relevant.
     *
     * @generated from field: string values = 5;
     */
    values: string;

    /**
     * An optional field for specifying data common to systems that reconcile
     * the package on the cluster.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.ReconciliationOptions reconciliation_options = 6;
     */
    reconciliationOptions?: ReconciliationOptions;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.CreateInstalledPackageRequest.
 * Use `create(CreateInstalledPackageRequestSchema)` to create a new message.
 */
export const CreateInstalledPackageRequestSchema: GenMessage<CreateInstalledPackageRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 6);

/**
 * UpdateInstalledPackageRequest
 *
 * Request for UpdateInstalledPackage. The intent is to reach the desired state specified
 * by the fields in the request, while leaving other fields intact. This is a whole
 * object "Update" semantics rather than "Patch" semantics. The caller will provide the
 * values for the fields below, which will replace, or be overlaid onto, the
 * corresponding fields in the existing resource. For example, with the
 * UpdateInstalledPackageRequest, it is not possible to change just the 'package version
 * reference' without also specifying 'values' field. As a side effect, not specifying the
 * 'values' field in the request means there are no values specified in the desired state.
 * So the meaning of each field value is describing the desired state of the corresponding
 * field in the resource after the update operation has completed the renconciliation.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.UpdateInstalledPackageRequest
 */
export type UpdateInstalledPackageRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.UpdateInstalledPackageRequest"> & {
    /**
     * A reference uniquely identifying the installed package being updated.
     * Required
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;

    /**
     * For helm this will be the exact version in VersionReference.version
     * For fluxv2 this could be any semver constraint expression
     * For other plugins we can extend the VersionReference as needed. Optional
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.VersionReference pkg_version_reference = 2;
     */
    pkgVersionReference?: VersionReference;

    /**
     * An optional serialized values string to be included when templating a
     * package in the format expected by the plugin. Included when the backend
     * format doesn't use secrets or configmaps for values or supports both.
     * These values are layered on top of any values refs above, when
     * relevant.
     *
     * @generated from field: string values = 3;
     */
    values: string;

    /**
     * An optional field for specifying data common to systems that reconcile
     * the package on the cluster.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.ReconciliationOptions reconciliation_options = 4;
     */
    reconciliationOptions?: ReconciliationOptions;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.UpdateInstalledPackageRequest.
 * Use `create(UpdateInstalledPackageRequestSchema)` to create a new message.
 */
export const UpdateInstalledPackageRequestSchema: GenMessage<UpdateInstalledPackageRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 7);

/**
 * DeleteInstalledPackageRequest
 *
 * Request for DeleteInstalledPackage
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.DeleteInstalledPackageRequest
 */
export type DeleteInstalledPackageRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.DeleteInstalledPackageRequest"> & {
    /**
     * A reference to uniquely identify the installed package to be deleted.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.DeleteInstalledPackageRequest.
 * Use `create(DeleteInstalledPackageRequestSchema)` to create a new message.
 */
export const DeleteInstalledPackageRequestSchema: GenMessage<DeleteInstalledPackageRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 8);

/**
 * GetInstalledPackageResourceRefsRequest
 *
 * Request for GetInstalledPackageResourceRefs
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageResourceRefsRequest
 */
export type GetInstalledPackageResourceRefsRequest =
  Message<"kubeappsapis.core.packages.v1alpha1.GetInstalledPackageResourceRefsRequest"> & {
    /**
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageResourceRefsRequest.
 * Use `create(GetInstalledPackageResourceRefsRequestSchema)` to create a new message.
 */
export const GetInstalledPackageResourceRefsRequestSchema: GenMessage<GetInstalledPackageResourceRefsRequest> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 9);

/**
 * GetAvailablePackageSummariesResponse
 *
 * Response for GetAvailablePackageSummaries
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{"available_package_summaries": [{}]}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageSummariesResponse
 */
export type GetAvailablePackageSummariesResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageSummariesResponse"> & {
    /**
     * Available packages summaries
     *
     * List of AvailablePackageSummary
     *
     * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.AvailablePackageSummary available_package_summaries = 1;
     */
    availablePackageSummaries: AvailablePackageSummary[];

    /**
     * Next page token
     *
     * This field represents the pagination token to retrieve the next page of
     * results. If the value is "", it means no further results for the request.
     *
     * @generated from field: string next_page_token = 2;
     */
    nextPageToken: string;

    /**
     * Categories
     *
     * This optional field contains the distinct category names considering the FilterOptions.
     *
     * @generated from field: repeated string categories = 3;
     */
    categories: string[];
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageSummariesResponse.
 * Use `create(GetAvailablePackageSummariesResponseSchema)` to create a new message.
 */
export const GetAvailablePackageSummariesResponseSchema: GenMessage<GetAvailablePackageSummariesResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 10);

/**
 * GetAvailablePackageDetailResponse
 *
 * Response for GetAvailablePackageDetail
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{"available_package_detail": [{}]}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageDetailResponse
 */
export type GetAvailablePackageDetailResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageDetailResponse"> & {
    /**
     * Available package detail
     *
     * The requested AvailablePackageDetail
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageDetail available_package_detail = 1;
     */
    availablePackageDetail?: AvailablePackageDetail;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageDetailResponse.
 * Use `create(GetAvailablePackageDetailResponseSchema)` to create a new message.
 */
export const GetAvailablePackageDetailResponseSchema: GenMessage<GetAvailablePackageDetailResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 11);

/**
 * GetAvailablePackageVersionsResponse
 *
 * Response for GetAvailablePackageVersions
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{"package_app_versions": [{}]}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageVersionsResponse
 */
export type GetAvailablePackageVersionsResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageVersionsResponse"> & {
    /**
     * Package app versions
     *
     * By default (when version_query is empty or ignored) the response
     * should contain an ordered summary of versions including the most recent three
     * patch versions of the most recent three minor versions of the most recent three
     * major versions when available, something like:
     * [
     *   { pkg_version: "10.3.19", app_version: "2.16.8" },
     *   { pkg_version: "10.3.18", app_version: "2.16.8" },
     *   { pkg_version: "10.3.17", app_version: "2.16.7" },
     *   { pkg_version: "10.2.6", app_version: "2.15.3" },
     *   { pkg_version: "10.2.5", app_version: "2.15.2" },
     *   { pkg_version: "10.2.4", app_version: "2.15.2" },
     *   { pkg_version: "10.1.8", app_version: "2.13.5" },
     *   { pkg_version: "10.1.7", app_version: "2.13.5" },
     *   { pkg_version: "10.1.6", app_version: "2.13.5" },
     *   { pkg_version: "9.5.4", app_version: "2.8.9" },
     *   ...
     *   { pkg_version: "8.2.5", app_version: "1.19.5" },
     *   ...
     * ]
     * If a version_query is present and the plugin chooses to support it,
     * the full history of versions matching the version query should be returned.
     *
     * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.PackageAppVersion package_app_versions = 1;
     */
    packageAppVersions: PackageAppVersion[];
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageVersionsResponse.
 * Use `create(GetAvailablePackageVersionsResponseSchema)` to create a new message.
 */
export const GetAvailablePackageVersionsResponseSchema: GenMessage<GetAvailablePackageVersionsResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 12);

/**
 * GetAvailablePackageMetadatasResponse
 *
 * Response for GetAvailablePackageMetadatas
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageMetadatasResponse
 */
export type GetAvailablePackageMetadatasResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetAvailablePackageMetadatasResponse"> & {
    /**
     * Available Package Reference
     *
     * The reference to the available package related to this metadata.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * Package Metadata
     *
     * A list of metadata associated with this available package.
     *
     * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.PackageMetadata package_metadata = 2;
     */
    packageMetadata: PackageMetadata[];
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetAvailablePackageMetadatasResponse.
 * Use `create(GetAvailablePackageMetadatasResponseSchema)` to create a new message.
 */
export const GetAvailablePackageMetadatasResponseSchema: GenMessage<GetAvailablePackageMetadatasResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 13);

/**
 * GetInstalledPackageSummariesResponse
 *
 * Response for GetInstalledPackageSummaries
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageSummariesResponse
 */
export type GetInstalledPackageSummariesResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetInstalledPackageSummariesResponse"> & {
    /**
     * Installed packages summaries
     *
     * List of InstalledPackageSummary
     *
     * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.InstalledPackageSummary installed_package_summaries = 1;
     */
    installedPackageSummaries: InstalledPackageSummary[];

    /**
     * Next page token
     *
     * This field represents the pagination token to retrieve the next page of
     * results. If the value is "", it means no further results for the request.
     *
     * @generated from field: string next_page_token = 2;
     */
    nextPageToken: string;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageSummariesResponse.
 * Use `create(GetInstalledPackageSummariesResponseSchema)` to create a new message.
 */
export const GetInstalledPackageSummariesResponseSchema: GenMessage<GetInstalledPackageSummariesResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 14);

/**
 * GetInstalledPackageDetailResponse
 *
 * Response for GetInstalledPackageDetail
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{"installed_package_detail": [{}]}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageDetailResponse
 */
export type GetInstalledPackageDetailResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetInstalledPackageDetailResponse"> & {
    /**
     * InstalledPackageDetail
     *
     * The requested InstalledPackageDetail
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageDetail installed_package_detail = 1;
     */
    installedPackageDetail?: InstalledPackageDetail;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageDetailResponse.
 * Use `create(GetInstalledPackageDetailResponseSchema)` to create a new message.
 */
export const GetInstalledPackageDetailResponseSchema: GenMessage<GetInstalledPackageDetailResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 15);

/**
 * CreateInstalledPackageResponse
 *
 * Response for CreateInstalledPackage
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{"installed_package_ref": {}}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.CreateInstalledPackageResponse
 */
export type CreateInstalledPackageResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.CreateInstalledPackageResponse"> & {
    /**
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.CreateInstalledPackageResponse.
 * Use `create(CreateInstalledPackageResponseSchema)` to create a new message.
 */
export const CreateInstalledPackageResponseSchema: GenMessage<CreateInstalledPackageResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 16);

/**
 * UpdateInstalledPackageResponse
 *
 * Response for UpdateInstalledPackage
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{"installed_package_ref": {}}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.UpdateInstalledPackageResponse
 */
export type UpdateInstalledPackageResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.UpdateInstalledPackageResponse"> & {
    /**
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.UpdateInstalledPackageResponse.
 * Use `create(UpdateInstalledPackageResponseSchema)` to create a new message.
 */
export const UpdateInstalledPackageResponseSchema: GenMessage<UpdateInstalledPackageResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 17);

/**
 * DeleteInstalledPackageResponse
 *
 * Response for DeleteInstalledPackage
 *
 * For future extensibility only.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.DeleteInstalledPackageResponse
 */
export type DeleteInstalledPackageResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.DeleteInstalledPackageResponse"> & {};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.DeleteInstalledPackageResponse.
 * Use `create(DeleteInstalledPackageResponseSchema)` to create a new message.
 */
export const DeleteInstalledPackageResponseSchema: GenMessage<DeleteInstalledPackageResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 18);

/**
 * GetInstalledPackageResourceRefsResponse
 *
 * Response for GetInstalledPackageResourceRefs
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageResourceRefsResponse
 */
export type GetInstalledPackageResourceRefsResponse =
  Message<"kubeappsapis.core.packages.v1alpha1.GetInstalledPackageResourceRefsResponse"> & {
    /**
     * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
     */
    context?: Context;

    /**
     * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.ResourceRef resource_refs = 2;
     */
    resourceRefs: ResourceRef[];
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.GetInstalledPackageResourceRefsResponse.
 * Use `create(GetInstalledPackageResourceRefsResponseSchema)` to create a new message.
 */
export const GetInstalledPackageResourceRefsResponseSchema: GenMessage<GetInstalledPackageResourceRefsResponse> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 19);

/**
 * AvailablePackageSummary
 *
 * An AvailablePackageSummary provides a summary of a package available for installation
 * useful when aggregating many available packages.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.AvailablePackageSummary
 */
export type AvailablePackageSummary =
  Message<"kubeappsapis.core.packages.v1alpha1.AvailablePackageSummary"> & {
    /**
     * Available package reference
     *
     * A reference uniquely identifying the package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * Available package name
     *
     * The name of the available package
     *
     * @generated from field: string name = 2;
     */
    name: string;

    /**
     * Latest available version
     *
     * The latest version available for this package. Often expected when viewing
     * a summary of many available packages.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion latest_version = 3;
     */
    latestVersion?: PackageAppVersion;

    /**
     * Available package Icon URL
     *
     * A url for an icon.
     *
     * @generated from field: string icon_url = 4;
     */
    iconUrl: string;

    /**
     * Available package display name
     *
     * A name as displayed to users
     *
     * @generated from field: string display_name = 5;
     */
    displayName: string;

    /**
     * Available package short description
     *
     * A short description of the app provided by the package
     *
     * @generated from field: string short_description = 6;
     */
    shortDescription: string;

    /**
     * Available package categories
     *
     * A user-facing list of category names useful for creating richer user interfaces.
     * Plugins can choose not to implement this
     *
     * @generated from field: repeated string categories = 7;
     */
    categories: string[];
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.AvailablePackageSummary.
 * Use `create(AvailablePackageSummarySchema)` to create a new message.
 */
export const AvailablePackageSummarySchema: GenMessage<AvailablePackageSummary> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 20);

/**
 * AvailablePackageDetail
 *
 * An AvailablePackageDetail provides additional details required when
 * inspecting an individual package.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.AvailablePackageDetail
 */
export type AvailablePackageDetail =
  Message<"kubeappsapis.core.packages.v1alpha1.AvailablePackageDetail"> & {
    /**
     * Available package reference
     *
     * A reference uniquely identifying the package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 1;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * Available package name
     *
     * The name of the available package
     *
     * @generated from field: string name = 2;
     */
    name: string;

    /**
     * Available version
     *
     * The version of the package and application.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion version = 3;
     */
    version?: PackageAppVersion;

    /**
     * the url of the package repository that contains this package
     *
     * @generated from field: string repo_url = 4;
     */
    repoUrl: string;

    /**
     * the url of the "home" for the package
     *
     * @generated from field: string home_url = 5;
     */
    homeUrl: string;

    /**
     * Available package icon URL
     *
     * A url for an icon.
     *
     * @generated from field: string icon_url = 6;
     */
    iconUrl: string;

    /**
     * Available package display name
     *
     * A name as displayed to users
     *
     * @generated from field: string display_name = 7;
     */
    displayName: string;

    /**
     * Available package short description
     *
     * A short description of the app provided by the package
     *
     * @generated from field: string short_description = 8;
     */
    shortDescription: string;

    /**
     * Available package long description
     *
     * A longer description of the package, a few sentences.
     *
     * @generated from field: string long_description = 9;
     */
    longDescription: string;

    /**
     * Available package readme
     *
     * A longer README with potentially pages of formatted Markdown.
     *
     * @generated from field: string readme = 10;
     */
    readme: string;

    /**
     * Available package default values
     *
     * An example of default values used during package templating that can serve
     * as documentation or a starting point for user customization.
     *
     * @generated from field: string default_values = 11;
     */
    defaultValues: string;

    /**
     * Available package additional default values
     *
     * A package may contain additional default value files for specific scenarios,
     * such as values_production.yaml or values_dev.yaml
     *
     * @generated from field: map<string, string> additional_default_values = 17;
     */
    additionalDefaultValues: { [key: string]: string };

    /**
     * @generated from field: string values_schema = 12;
     */
    valuesSchema: string;

    /**
     * source urls for the package
     *
     * @generated from field: repeated string source_urls = 13;
     */
    sourceUrls: string[];

    /**
     * Available package maintainers
     *
     * List of Maintainer
     *
     * @generated from field: repeated kubeappsapis.core.packages.v1alpha1.Maintainer maintainers = 14;
     */
    maintainers: Maintainer[];

    /**
     * Available package categories
     *
     * A user-facing list of category names useful for creating richer user interfaces.
     * Plugins can choose not to implement this
     *
     * @generated from field: repeated string categories = 15;
     */
    categories: string[];

    /**
     * Custom data added by the plugin
     *
     * A plugin can define custom details for data which is not yet, or never will
     * be specified in the core.packaging.CreateInstalledPackageRequest fields. The use
     * of an `Any` field means that each plugin can define the structure of this
     * message as required, while still satisfying the core interface.
     * See https://developers.google.com/protocol-buffers/docs/proto3#any
     *
     * @generated from field: google.protobuf.Any custom_detail = 16;
     */
    customDetail?: Any;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.AvailablePackageDetail.
 * Use `create(AvailablePackageDetailSchema)` to create a new message.
 */
export const AvailablePackageDetailSchema: GenMessage<AvailablePackageDetail> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 21);

/**
 * InstalledPackageSummary
 *
 * An InstalledPackageSummary provides a summary of an installed package
 * useful when aggregating many installed packages.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.InstalledPackageSummary
 */
export type InstalledPackageSummary =
  Message<"kubeappsapis.core.packages.v1alpha1.InstalledPackageSummary"> & {
    /**
     * InstalledPackageReference
     *
     * A reference uniquely identifying the package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;

    /**
     * Name
     *
     * A name given to the installation of the package (eg. "my-postgresql-for-testing").
     *
     * @generated from field: string name = 2;
     */
    name: string;

    /**
     * PkgVersionReference
     *
     * The package version reference defines a version or constraint limiting
     * matching package versions.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.VersionReference pkg_version_reference = 3;
     */
    pkgVersionReference?: VersionReference;

    /**
     * CurrentVersion
     *
     * The current version of the package being reconciled, which may be
     * in one of these states:
     *  - has been successfully installed/upgraded or
     *  - is currently being installed/upgraded or
     *  - has failed to install/upgrade
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion current_version = 4;
     */
    currentVersion?: PackageAppVersion;

    /**
     * Installed package icon URL
     *
     * A url for an icon.
     *
     * @generated from field: string icon_url = 5;
     */
    iconUrl: string;

    /**
     * PackageDisplayName
     *
     * The package name as displayed to users (provided by the package, eg. "PostgreSQL")
     *
     * @generated from field: string pkg_display_name = 6;
     */
    pkgDisplayName: string;

    /**
     * ShortDescription
     *
     * A short description of the package (provided by the package)
     *
     * @generated from field: string short_description = 7;
     */
    shortDescription: string;

    /**
     * LatestMatchingVersion
     *
     * Only non-empty if an available upgrade matches the specified pkg_version_reference.
     * For example, if the pkg_version_reference is ">10.3.0 < 10.4.0" and 10.3.1
     * is installed, then:
     *   * if 10.3.2 is available, latest_matching_version should be 10.3.2, but
     *   * if 10.4 is available while >10.3.1 is not, this should remain empty.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion latest_matching_version = 8;
     */
    latestMatchingVersion?: PackageAppVersion;

    /**
     * LatestVersion
     *
     * The latest version available for this package, regardless of the pkg_version_reference.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion latest_version = 9;
     */
    latestVersion?: PackageAppVersion;

    /**
     * Status
     *
     * The current status of the installed package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus status = 10;
     */
    status?: InstalledPackageStatus;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.InstalledPackageSummary.
 * Use `create(InstalledPackageSummarySchema)` to create a new message.
 */
export const InstalledPackageSummarySchema: GenMessage<InstalledPackageSummary> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 22);

/**
 * InstalledPackageDetail
 *
 * An InstalledPackageDetail includes details about the installed package that are
 * typically useful when presenting a single installed package.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.InstalledPackageDetail
 */
export type InstalledPackageDetail =
  Message<"kubeappsapis.core.packages.v1alpha1.InstalledPackageDetail"> & {
    /**
     * InstalledPackageReference
     *
     * A reference uniquely identifying the installed package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageReference installed_package_ref = 1;
     */
    installedPackageRef?: InstalledPackageReference;

    /**
     * PkgVersionReference
     *
     * The package version reference defines a version or constraint limiting
     * matching package versions.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.VersionReference pkg_version_reference = 2;
     */
    pkgVersionReference?: VersionReference;

    /**
     * Installed package name
     *
     * The name given to the installed package
     *
     * @generated from field: string name = 3;
     */
    name: string;

    /**
     * CurrentVersion
     *
     * The version of the package which is currently installed.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion current_version = 4;
     */
    currentVersion?: PackageAppVersion;

    /**
     * ValuesApplied
     *
     * The values applied currently for the installed package.
     *
     * @generated from field: string values_applied = 5;
     */
    valuesApplied: string;

    /**
     * ReconciliationOptions
     *
     * An optional field specifying data common to systems that reconcile
     * the package installation on the cluster asynchronously. In particular,
     * this specifies the service account used to perform the reconcilliation.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.ReconciliationOptions reconciliation_options = 6;
     */
    reconciliationOptions?: ReconciliationOptions;

    /**
     * Status
     *
     * The current status of the installed package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus status = 7;
     */
    status?: InstalledPackageStatus;

    /**
     * PostInstallationNotes
     *
     * Optional notes generated by package and intended for the user post installation.
     *
     * @generated from field: string post_installation_notes = 8;
     */
    postInstallationNotes: string;

    /**
     * Available package reference
     *
     * A reference to the available package for this installation.
     * Useful to lookup the package display name, icon and other info.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.AvailablePackageReference available_package_ref = 9;
     */
    availablePackageRef?: AvailablePackageReference;

    /**
     * LatestMatchingVersion
     *
     * Only non-empty if an available upgrade matches the specified pkg_version_reference.
     * For example, if the pkg_version_reference is ">10.3.0 < 10.4.0" and 10.3.1
     * is installed, then:
     *   * if 10.3.2 is available, latest_matching_version should be 10.3.2, but
     *   * if 10.4 is available while >10.3.1 is not, this should remain empty.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion latest_matching_version = 10;
     */
    latestMatchingVersion?: PackageAppVersion;

    /**
     * LatestVersion
     *
     * The latest version available for this package, regardless of the pkg_version_reference.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.PackageAppVersion latest_version = 11;
     */
    latestVersion?: PackageAppVersion;

    /**
     * Custom data added by the plugin
     *
     * A plugin can define custom details for data which is not yet, or never will
     * be specified in the core.packaging.CreateInstalledPackageRequest fields. The use
     * of an `Any` field means that each plugin can define the structure of this
     * message as required, while still satisfying the core interface.
     * See https://developers.google.com/protocol-buffers/docs/proto3#any
     *
     * @generated from field: google.protobuf.Any custom_detail = 14;
     */
    customDetail?: Any;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.InstalledPackageDetail.
 * Use `create(InstalledPackageDetailSchema)` to create a new message.
 */
export const InstalledPackageDetailSchema: GenMessage<InstalledPackageDetail> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 23);

/**
 * Context
 *
 * A Context specifies the context of the message
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.Context
 */
export type Context = Message<"kubeappsapis.core.packages.v1alpha1.Context"> & {
  /**
   * Cluster
   *
   * A cluster name can be provided to target a specific cluster if multiple
   * clusters are configured, otherwise all clusters will be assumed.
   *
   * @generated from field: string cluster = 1;
   */
  cluster: string;

  /**
   * Namespace
   *
   * A namespace must be provided if the context of the operation is for a resource
   * or resources in a particular namespace.
   * For requests to list items, not including a namespace here implies that the context
   * for the request is everything the requesting user can read, though the result can
   * be filtered by any filtering options of the request. Plugins may choose to return
   * Unimplemented for some queries for which we do not yet have a need.
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.Context.
 * Use `create(ContextSchema)` to create a new message.
 */
export const ContextSchema: GenMessage<Context> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 24);

/**
 * AvailablePackageReference
 *
 * An AvailablePackageReference has the minimum information required to uniquely
 * identify an available package. This is re-used on the summary and details of an
 * available package.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.AvailablePackageReference
 */
export type AvailablePackageReference =
  Message<"kubeappsapis.core.packages.v1alpha1.AvailablePackageReference"> & {
    /**
     * Available package context
     *
     * The context (cluster/namespace) for the package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
     */
    context?: Context;

    /**
     * Available package identifier
     *
     * The fully qualified identifier for the available package
     * (ie. a unique name for the context). For some packaging systems
     * (particularly those where an available package is backed by a CR) this
     * will just be the name, but for others such as those where an available
     * package is not backed by a CR (eg. standard helm) it may be necessary
     * to include the repository in the name or even the repo namespace
     * to ensure this is unique.
     * For example two helm repositories can define
     * an "apache" chart that is available globally, the names would need to
     * encode that to be unique (ie. "repoA:apache" and "repoB:apache").
     *
     * @generated from field: string identifier = 2;
     */
    identifier: string;

    /**
     * Plugin for the available package
     *
     * The plugin used to interact with this available package.
     * This field should be omitted when the request is in the context of a specific plugin.
     *
     * @generated from field: kubeappsapis.core.plugins.v1alpha1.Plugin plugin = 3;
     */
    plugin?: Plugin;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.AvailablePackageReference.
 * Use `create(AvailablePackageReferenceSchema)` to create a new message.
 */
export const AvailablePackageReferenceSchema: GenMessage<AvailablePackageReference> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 25);

/**
 * Maintainer
 *
 * Maintainers for the package.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.Maintainer
 */
export type Maintainer = Message<"kubeappsapis.core.packages.v1alpha1.Maintainer"> & {
  /**
   * Maintainer name
   *
   * A maintainer name
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Maintainer email
   *
   * A maintainer email
   *
   * @generated from field: string email = 2;
   */
  email: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.Maintainer.
 * Use `create(MaintainerSchema)` to create a new message.
 */
export const MaintainerSchema: GenMessage<Maintainer> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 26);

/**
 * FilterOptions
 *
 * FilterOptions available when requesting summaries
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.FilterOptions
 */
export type FilterOptions = Message<"kubeappsapis.core.packages.v1alpha1.FilterOptions"> & {
  /**
   * Text query
   *
   * Text query for the request
   *
   * @generated from field: string query = 1;
   */
  query: string;

  /**
   * Categories
   *
   * Collection of categories for the request
   *
   * @generated from field: repeated string categories = 2;
   */
  categories: string[];

  /**
   * Repositories
   *
   * Collection of repositories where the packages belong to
   *
   * @generated from field: repeated string repositories = 3;
   */
  repositories: string[];

  /**
   * Package version
   *
   * Package version for the request
   *
   * @generated from field: string pkg_version = 4;
   */
  pkgVersion: string;

  /**
   * App version
   *
   * Packaged app version for the request
   *
   * @generated from field: string app_version = 5;
   */
  appVersion: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.FilterOptions.
 * Use `create(FilterOptionsSchema)` to create a new message.
 */
export const FilterOptionsSchema: GenMessage<FilterOptions> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 27);

/**
 * PaginationOptions
 *
 * The PaginationOptions based on the example proto at:
 * https://cloud.google.com/apis/design/design_patterns#list_pagination
 * just encapsulated in a message so it can be reused on different request messages.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.PaginationOptions
 */
export type PaginationOptions = Message<"kubeappsapis.core.packages.v1alpha1.PaginationOptions"> & {
  /**
   * Page token
   *
   * The client uses this field to request a specific page of the list results.
   *
   * @generated from field: string page_token = 1;
   */
  pageToken: string;

  /**
   * Page size
   *
   * Clients use this field to specify the maximum number of results to be
   * returned by the server. The server may further constrain the maximum number
   * of results returned in a single page. If the page_size is 0, the server
   * will decide the number of results to be returned.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize: number;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.PaginationOptions.
 * Use `create(PaginationOptionsSchema)` to create a new message.
 */
export const PaginationOptionsSchema: GenMessage<PaginationOptions> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 28);

/**
 * InstalledPackageReference
 *
 * An InstalledPackageReference has the minimum information required to uniquely
 * identify an installed package.
 *
 * TODO: add example for API docs
 * option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_schema) = {
 *   example: '{}'
 * };
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.InstalledPackageReference
 */
export type InstalledPackageReference =
  Message<"kubeappsapis.core.packages.v1alpha1.InstalledPackageReference"> & {
    /**
     * Installed package context
     *
     * The context (cluster/namespace) for the package.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.Context context = 1;
     */
    context?: Context;

    /**
     * The fully qualified identifier for the installed package
     * (ie. a unique name for the context).
     *
     * @generated from field: string identifier = 2;
     */
    identifier: string;

    /**
     * The plugin used to identify and interact with the installed package.
     * This field can be omitted when the request is in the context of a specific plugin.
     *
     * @generated from field: kubeappsapis.core.plugins.v1alpha1.Plugin plugin = 3;
     */
    plugin?: Plugin;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.InstalledPackageReference.
 * Use `create(InstalledPackageReferenceSchema)` to create a new message.
 */
export const InstalledPackageReferenceSchema: GenMessage<InstalledPackageReference> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 29);

/**
 * VersionReference
 *
 * A VersionReference defines a version or constraint limiting matching versions.
 * The reason it is a separate message is so that in the future we can add other
 * fields as necessary (such as something similar to Carvel's `prereleases` option
 * to its versionSelection).
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.VersionReference
 */
export type VersionReference = Message<"kubeappsapis.core.packages.v1alpha1.VersionReference"> & {
  /**
   * Version
   *
   * The format of the version constraint depends on the backend. For example,
   * for a flux v2 it's a semver expression, such as ">=10.3 < 10.4"
   *
   * @generated from field: string version = 1;
   */
  version: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.VersionReference.
 * Use `create(VersionReferenceSchema)` to create a new message.
 */
export const VersionReferenceSchema: GenMessage<VersionReference> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 30);

/**
 * InstalledPackageStatus
 *
 * An InstalledPackageStatus reports on the current status of the installation.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus
 */
export type InstalledPackageStatus =
  Message<"kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus"> & {
    /**
     * Ready
     *
     * An indication of whether the installation is ready or not
     *
     * @generated from field: bool ready = 1;
     */
    ready: boolean;

    /**
     * Reason
     *
     * An enum indicating the reason for the current status.
     *
     * @generated from field: kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus.StatusReason reason = 2;
     */
    reason: InstalledPackageStatus_StatusReason;

    /**
     * UserReason
     *
     * Optional text to return for user context, which may be plugin specific.
     *
     * @generated from field: string user_reason = 3;
     */
    userReason: string;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus.
 * Use `create(InstalledPackageStatusSchema)` to create a new message.
 */
export const InstalledPackageStatusSchema: GenMessage<InstalledPackageStatus> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 31);

/**
 * StatusReason
 *
 * Generic reasons why an installed package may be ready or not.
 * These should make sense across different packaging plugins.
 *
 * @generated from enum kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus.StatusReason
 */
export enum InstalledPackageStatus_StatusReason {
  /**
   * @generated from enum value: STATUS_REASON_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_REASON_INSTALLED = 1;
   */
  INSTALLED = 1,

  /**
   * @generated from enum value: STATUS_REASON_UNINSTALLED = 2;
   */
  UNINSTALLED = 2,

  /**
   * @generated from enum value: STATUS_REASON_FAILED = 3;
   */
  FAILED = 3,

  /**
   * @generated from enum value: STATUS_REASON_PENDING = 4;
   */
  PENDING = 4,
}

/**
 * Describes the enum kubeappsapis.core.packages.v1alpha1.InstalledPackageStatus.StatusReason.
 */
export const InstalledPackageStatus_StatusReasonSchema: GenEnum<InstalledPackageStatus_StatusReason> =
  /*@__PURE__*/
  enumDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 31, 0);

/**
 * ReconciliationOptions
 *
 * ReconciliationOptions enable specifying standard fields for backends that continuously
 * reconcile a package install as new matching versions are released. Most of the naming
 * is from the flux HelmReleaseSpec though it maps directly to equivalent fields on Carvel's
 * InstalledPackage.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.ReconciliationOptions
 */
export type ReconciliationOptions =
  Message<"kubeappsapis.core.packages.v1alpha1.ReconciliationOptions"> & {
    /**
     * Reconciliation Interval
     *
     * The interval with which the package is checked for reconciliation (in time+unit)
     *
     * @generated from field: string interval = 1;
     */
    interval: string;

    /**
     * Suspend
     *
     * Whether reconciliation should be suspended until otherwise enabled.
     * This can be utilized to e.g. temporarily ignore chart changes, and
     * prevent a Helm release from getting upgraded
     *
     * @generated from field: bool suspend = 2;
     */
    suspend: boolean;

    /**
     * ServiceAccountName
     *
     * A name for a service account in the same namespace which should be used
     * to perform the reconciliation.
     *
     * @generated from field: string service_account_name = 3;
     */
    serviceAccountName: string;
  };

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.ReconciliationOptions.
 * Use `create(ReconciliationOptionsSchema)` to create a new message.
 */
export const ReconciliationOptionsSchema: GenMessage<ReconciliationOptions> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 32);

/**
 * Package AppVersion
 *
 * PackageAppVersion conveys both the package version and the packaged app version.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.PackageAppVersion
 */
export type PackageAppVersion = Message<"kubeappsapis.core.packages.v1alpha1.PackageAppVersion"> & {
  /**
   * Package version
   *
   * Version of the package itself
   *
   * @generated from field: string pkg_version = 1;
   */
  pkgVersion: string;

  /**
   * Application version
   *
   * Version of the packaged application
   *
   * @generated from field: string app_version = 2;
   */
  appVersion: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.PackageAppVersion.
 * Use `create(PackageAppVersionSchema)` to create a new message.
 */
export const PackageAppVersionSchema: GenMessage<PackageAppVersion> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 33);

/**
 * Package Metadata
 *
 * PackageMetadata contains info to display and fetch SBOMs, scan results
 * and other linked package metadata.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.PackageMetadata
 */
export type PackageMetadata = Message<"kubeappsapis.core.packages.v1alpha1.PackageMetadata"> & {
  /**
   * Media type
   *
   * Media type of this metadata
   *
   * @generated from field: string media_type = 1;
   */
  mediaType: string;

  /**
   * Artifact type
   *
   * Artifact type of this metadata
   *
   * @generated from field: string artifact_type = 2;
   */
  artifactType: string;

  /**
   * Digest
   *
   * Digest of this metadata
   *
   * @generated from field: string digest = 3;
   */
  digest: string;

  /**
   * Name
   *
   * Human readable name for this metadata.
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Description
   *
   * Human readable description for this metadata.
   *
   * @generated from field: string description = 5;
   */
  description: string;

  /**
   * URL
   *
   * The url reference for this metadata.
   *
   * @generated from field: string url = 6;
   */
  url: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.PackageMetadata.
 * Use `create(PackageMetadataSchema)` to create a new message.
 */
export const PackageMetadataSchema: GenMessage<PackageMetadata> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 34);

/**
 * Resource reference
 *
 * A reference to a Kubernetes resource related to a specific installed package.
 * The context (cluster) for each resource is that of the related
 * installed package.
 *
 * @generated from message kubeappsapis.core.packages.v1alpha1.ResourceRef
 */
export type ResourceRef = Message<"kubeappsapis.core.packages.v1alpha1.ResourceRef"> & {
  /**
   * The APIVersion directly from the resource has the group and version, eg. "apps/v1"
   * or just the version for core resources.
   *
   * @generated from field: string api_version = 1;
   */
  apiVersion: string;

  /**
   * The Kind directly from the templated manifest. Together with the APIVersion this
   * forms the GroupVersionKind.
   *
   * @generated from field: string kind = 2;
   */
  kind: string;

  /**
   * The name of the specific resource in the context of the installed package.
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * The namespace of the specific resource in the context of the installed
   * package. In most cases this will be identical to the namespace of the
   * installed package. Exceptions will be non-namespaced resources and packages
   * that install resources in other namespaces for special reasons.
   *
   * @generated from field: string namespace = 4;
   */
  namespace: string;
};

/**
 * Describes the message kubeappsapis.core.packages.v1alpha1.ResourceRef.
 * Use `create(ResourceRefSchema)` to create a new message.
 */
export const ResourceRefSchema: GenMessage<ResourceRef> =
  /*@__PURE__*/
  messageDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 35);

/**
 * Each packages v1alpha1 plugin must implement at least the following rpcs:
 *
 *
 * @generated from service kubeappsapis.core.packages.v1alpha1.PackagesService
 */
export const PackagesService: GenService<{
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetAvailablePackageSummaries
   */
  getAvailablePackageSummaries: {
    methodKind: "unary";
    input: typeof GetAvailablePackageSummariesRequestSchema;
    output: typeof GetAvailablePackageSummariesResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetAvailablePackageDetail
   */
  getAvailablePackageDetail: {
    methodKind: "unary";
    input: typeof GetAvailablePackageDetailRequestSchema;
    output: typeof GetAvailablePackageDetailResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetAvailablePackageVersions
   */
  getAvailablePackageVersions: {
    methodKind: "unary";
    input: typeof GetAvailablePackageVersionsRequestSchema;
    output: typeof GetAvailablePackageVersionsResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetAvailablePackageMetadatas
   */
  getAvailablePackageMetadatas: {
    methodKind: "unary";
    input: typeof GetAvailablePackageMetadatasRequestSchema;
    output: typeof GetAvailablePackageMetadatasResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetInstalledPackageSummaries
   */
  getInstalledPackageSummaries: {
    methodKind: "unary";
    input: typeof GetInstalledPackageSummariesRequestSchema;
    output: typeof GetInstalledPackageSummariesResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetInstalledPackageDetail
   */
  getInstalledPackageDetail: {
    methodKind: "unary";
    input: typeof GetInstalledPackageDetailRequestSchema;
    output: typeof GetInstalledPackageDetailResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.CreateInstalledPackage
   */
  createInstalledPackage: {
    methodKind: "unary";
    input: typeof CreateInstalledPackageRequestSchema;
    output: typeof CreateInstalledPackageResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.UpdateInstalledPackage
   */
  updateInstalledPackage: {
    methodKind: "unary";
    input: typeof UpdateInstalledPackageRequestSchema;
    output: typeof UpdateInstalledPackageResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.DeleteInstalledPackage
   */
  deleteInstalledPackage: {
    methodKind: "unary";
    input: typeof DeleteInstalledPackageRequestSchema;
    output: typeof DeleteInstalledPackageResponseSchema;
  };
  /**
   * @generated from rpc kubeappsapis.core.packages.v1alpha1.PackagesService.GetInstalledPackageResourceRefs
   */
  getInstalledPackageResourceRefs: {
    methodKind: "unary";
    input: typeof GetInstalledPackageResourceRefsRequestSchema;
    output: typeof GetInstalledPackageResourceRefsResponseSchema;
  };
}> = /*@__PURE__*/ serviceDesc(file_kubeappsapis_core_packages_v1alpha1_packages, 0);
